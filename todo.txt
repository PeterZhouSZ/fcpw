Priority:
1. implement mbvh/qbvh
---- implement traversal with node sorting
---- start search from specified node
---- set leafSize based on width in scene.inl, query width from enoki
---- profile triangle closestPoint w.o. early exit
---- modify cost to ensure most leaves contain #WIDTH primitives, no leaf should be empty
---- pad mbvh node?
---- enoki settings on ubuntu (geometry-box)
---- enable embree with enoki
2. load geometry directly into scene without file IO
3. add support for more geometries:
---- line segments (3d), beziers (3d), spheres
4. option to ignore certain primitives
5. more file formats (ply)
6. benchmark
7. travis CI
8. README (tutorial, features, benchmark, compiling, logo)

Optimizations and Features:
1. vectorize + parallelize bvh construction
2. support oriented bounding boxes/RSS
3. traversal optimization for closest point queries:
---- implement "queueless" closest point traversal
---- (for non-spatio-temporal (incoherent) queries) incrementally build spatial data
	  structure that stores pointers to nodes in the tree; bvh populates spatial data
	  structure while spatial data structure suggests which node to start queries from
4. traversal optimization for intersections:
---- implement "stackless" ray intersection traversal
---- (for non-spatio-temporal (incoherent) queries) incrementally build spatial data
	  structure that stores pointers to nodes in the tree; unlike closest point queries,
	  data structure(s) must store positions and directions
5. add support for more geometries:
---- subdivision surfaces, implicits, nurbs
6. packet (coherent) queries
---- breadth first ray tracing
7. refit bvh

Done:
1. Closest point and ray intersections queries leveraging coherency between queries
2. Bvh with various cost heuristics (Centroid Split, Surface Area, Volume,
									 Surface Area Overlap, Volume Overlap)
3. Spatial Split Bvh for non-uniform tessellation
4. Constructive Solid Geometry
5. Instancing
