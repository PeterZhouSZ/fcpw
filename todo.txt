Priority:
Test MBVH correctness:
-- bvh build statistics should be the same
-- try without primitive vectorization
-- try with different widths

1. enforce max tree depth & allocate fixed size stack for traversal on stack
2. sbvh - move_backward is very inefficient for large meshes
3. give the closest point a rough guess of direction to guide traversal (things can
   possibly go very wrong if guess is totally off for certain geometric distributions)
4. start search from specified node (and walk up/laterally in the tree)
5. mbvh
---- use user specified branching factor
---- clear scene memory when vectorizing primitives?
---- enoki settings on ubuntu & windows
---- sort nodes efficiently during traversal for closest points (by distance & direction)
---- start search from specified node (and walk up/laterally in the tree)
6. benchmark (https://github.com/jdumas/aabb_benchmark)
7. travis/circle CI
8. README (tutorial, features, benchmark, compiling, logo)

Future Optimizations & Features:
1. vectorize + thread bvh construction
2. support oriented bounding boxes + RSS
3. rebalance trees
4. traversal optimization for closest point queries:
---- implement "stackless" closest point traversal
---- (for non-spatio-temporal (incoherent) queries) incrementally build spatial data
	  structure while querying that stores pointers to nodes in the tree based on
	  positions and directions to boundary
5. traversal optimization for intersections:
---- same as cpqs
6. add support for more geometries:
---- beziers, libfive (+ exact distance to implicit), subdivision surfaces, nurbs
7. more file formats (ply)
8. packet (coherent) queries
---- keyword: breadth first ray tracing
9. refit bvh
10. double precision

Done:
1. Closest point and ray intersections queries leveraging coherency between queries
2. Bvh with various cost heuristics (Centroid Split, Surface Area, Volume,
									 Surface Area Overlap, Volume Overlap)
3. Spatial Split Bvh for non-uniform tessellation
4. Constructive Solid Geometry
5. Instancing
